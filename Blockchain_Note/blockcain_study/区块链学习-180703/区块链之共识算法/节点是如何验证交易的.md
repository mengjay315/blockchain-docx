# 节点如何验证交易的

## 简单支付验证(SPV)与轻钱包

**简单支付验证**是一种无须维护完整的区块链信息，**只需要保存所有的区块头部信息即可进行支付验证的技术**。该技术可以大大节省区块链支付验证用户的存储空间，减轻用户存储负担，降低区块链未来交易量剧增而给用户带来的压力。以比特币系统为例，节点只需保存所有区块头信息，即可进行交易支付验证。节点虽然不能独立验证交易，但能够从区块链其他节点获取交易验证的必要信息，从而完成交易支付验证，同时还可以得到整个区块链网络对交易的确认数。
要理解这个首先得理解两个概念：
一是**SPV**与**轻钱包**的区别。轻钱包指的是节点本地只保存与其自身相关的交易数据（尤其是可支配交易数据），但并不保存完整区块链信息的技术。**SPV的目标是验证某个支付是否真实存在，并得到了多少个确认**。比如爱丽丝（Alice）收到来自鲍伯（Bob）的一个通知，鲍伯声称已经从其账户中汇款一定数额的钱给了爱丽丝。如何快速验证该支付的真实性，是SPV的工作目标。轻钱包的目标不仅是支付验证，而且是用于管理节点自身的资产收入、支付等信息。比如爱丽丝使用轻钱包管理自身在区块链的收入信息、支出信息，在本地只保存与爱丽丝自身相关的交易数据，尤其是可支配交易数据。轻钱包与SPV的最大区别是，**轻钱包节点仍需下载每个新区块的全部数据并进行解析，获取并本地存储与自身相关的交易数据，只是无须在本地保存全部数据而已**。**而SPV节点不需要下载新区块的全部数据，只需要保存区块头部信息即可。虽然轻钱包中部分借鉴了SPV的理念，但和SPV是完全不同的**。
二是**区块链支付验证**与**区块链交易验证**的区别。SPV指的是区块链支付验证，而不是区块链交易验证。这两种验证方式存在很大的区别。区块链交易验证的过程比较复杂，包括账户余额验证、双重支付判断等，通常由保存区块链完整信息的区块链验证节点来完成。而支付验证的过程比较简单，只是判断该笔支付交易是否已经得到了区块链节点共识验证，并得到了多少的确认数即可。还是以比特币系统为例，用户爱丽丝收到来自鲍伯的通知，鲍伯声称已经从其账户中汇款一定数额的钱给爱丽丝。爱丽丝进行交易验证的过程如下：首先，爱丽丝遍历完整的区块链账本，在区块链账本的交易中保存了鲍伯的历史交易信息（包括鲍伯的汇款账户、鲍伯的签名、历史收款人的地址以及汇款金额信息等），查询鲍伯的账户，就可以判断鲍伯提供的账户是否有足够的余额，如果余额不足则交易验证失败；其次，爱丽丝要根据区块链账本判断鲍伯是否已经支出了这个账户上的钱给别人，即是否存在双重支付问题，如果存在则交易验证失败；最后，判断鲍伯是否拥有其提供账户的支配权，如果判断失败则交易验证失败。而如果爱丽丝只是进行支付验证，则过程简单得多：通过SPV，爱丽丝可以进行支付快速验证，即检查此项支付交易是否已经被收录存储于区块链中，并得到了多少个确认数，就可以判断支付验证的合法性。

## 区块链交易的发起和验证概述

交易的发起

单笔交易是整个区块链的基本元素，这里面主要包含价值输出方发起交易、其他节点验证交易两个动作。整个交易的信任完全是依赖非对称加密算法进行保证，非对称加密算法需要两个密钥：公钥和私钥。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。比如现有付款人1-》收款人2、付款人2（前一交易的收款人2）-》收款人3两笔交易，付款人1-》收款人2的交易为付款人2-》收款人3交易的前序交易。付款人2用自己的私钥制作数字签名，即用前序交易中涉及到收款人2（自己）的信息Y（一般包括前序交易的唯一哈希值、收款人2的公钥地址哈希、收款人2在前序交易中的排序、收款人2收到的金额等信息）作为明文计算密文X。付款人2将X作为数字签名和自己的公钥地址附在交易中发给收款人3。

交易的验证

付款人2到收款人3的交易发起后，各节点需要验证价值由付款人2发出以及价值可追溯到付款人1-》收款人2的交易数据。验证节点用付款人2提供的公钥地址解密数字签名X得到明文Y，并与区块链上记录的内容进行比对，验证付款人2提供的公钥地址是否由付款人2持有（付款人持有账户）；同时，计算付款人2提供的公钥地址的哈希，继续与Y中的收款人2的公钥地址哈希进行比对，验证付款人2提供的公钥地址是否为前序交易的收款地址（付款人账户持有价值），进而验证发出的价值是否可追溯到付款人1-》收款人2的交易。如两次比对一致，则付款人2-》收款人3交易有效。

区块的打包和上链

区块的打包

在分布式网络下，为了降低记账成本并保证安全性，不是逐笔对交易进行全网共识进而上链，而是将一段时间内所有交易数据汇总打包成块，并通过竞争性记账规则确定上链。在区块打包过程中，数字摘要是重要的工具，它是将任意长度的消息变成固定长度的特定短消息，最后将一个区块内包含的所有信息概括为一个数字摘要，不同的原始消息会生成不同的摘要，但根据摘要无法逆推出原始消息。区块由区块体和区块头组成，区块体包含了大量交易信息，每笔交易有唯一地哈希值代表，往上走通过把相邻的两个哈希值合并成一个[字符](http://www.hqpcb.com/quote/)串，然后运算这个字符串的哈希，这样得到了一个“父哈希”，同样的计算方式往上走，可以得到数目更少的新一级哈希，最终形成一棵倒挂的树，到了树根的这个位置，就剩下一个根哈希了，也就是Merkle根节点，它总结了所有的交易信息。

除了Merkle根节点，区块头还包括上一区块的头哈希值、时间戳、难度值和随机数，而头哈希是区块头五要素的哈希值。一个头哈希就可以总结整个区块所有交易信息、时间戳、前一区块头哈希、工作量证明等所有信息，任何信息的改变都将直接引起头哈希的变化。

区块的上链

区块打包完成后，通过共识机制解决了分布式账本结构下达成一致并抗攻击的问题，它解决了去中心化基础上的节点间互信问题，是保障区块链系统持续安全运行的关键。基于分布式网络中各节点的信任基础不同，可以分为工作量证明机制、拜占庭容错机制等，它们在节点进出进制、抗攻击性等方面各有优势。以工作量证明机制为例来说明共识机制的原理。达成共识需要一定的标准和规则，达到标准就可以获取记账权，同时这个标准或者规则是不能低成本实现的，否则记账的权威性和安全性容易受到挑战。基于数学难度的计算工作量证明机制简单理解就是一份证明，用来确认你做过一定量的工作。因为监测工作的整个过程通常是极为低效的，而通过对工作的结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。比如现实生活中的毕业证、驾驶证等等，也是通过[检验](http://www.hqpcb.com/quote/)结果的方式（通过相关的考试）所取得的证明。工作量证明解决了完全去中心化、节点自由进出的情况下，记账权的确认问题。

同时，工作量证明也保障了抗攻击性。多数人投票的最长链投入了最大的工作量，如果大多数[CPU](http://www.elecfans.com/tags/cpu/)工作量被诚实的节点控制，诚实的链条会增长很快，从而超过其他的链。攻击者为了修改过去的块，必须重做当前块以及之后的所有块，并赶上并超过诚实节点的工作。当下一区块添加时，慢的攻击者赶超的可能性以指数级方式减少，从而抵御恶意攻击。