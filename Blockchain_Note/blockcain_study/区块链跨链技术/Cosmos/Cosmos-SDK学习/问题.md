# 问题：

```go
// NewNameServiceApp is a constructor function for nameServiceApp
func NewNameServiceApp(logger log.Logger, db dbm.DB) *nameServiceApp {

	// First define the top level codec that will be shared by the different modules
	cdc := MakeCodec()
    
```

最终返回的结果：

![](assets/DeepinScreenshot_select-area_20190802181824.png)

```go

// MakeCodec generates the necessary codecs for Amino
func MakeCodec() *codec.Codec {
	var cdc = codec.New()
	ModuleBasics.RegisterCodec(cdc)
	sdk.RegisterCodec(cdc)
	codec.RegisterCrypto(cdc)
	return cdc
}
```

MakeCodec ：生成**Amino**必须的编解码器，**Amino**是什么？

> ModuleBasics.RegisterCodec(cdc), 注册基础模块，下面的每个模块都有各自的注册函数

![](assets/DeepinScreenshot_select-area_20190802175927.png)

以geneaccounts.AppMoudleBasic{},为例，这个注册函数不做任何操作，这里的注册都实现了什么？

![](assets/DeepinScreenshot_select-area_20190802180225.png)

```go
sdk.RegisterCodec(cdc)
// Register the sdk message type
func RegisterCodec(cdc *codec.Codec) {
	cdc.RegisterInterface((*Msg)(nil), nil)
	cdc.RegisterInterface((*Tx)(nil), nil)
}
```

注册sdk 的信息类型， RegisterCodec(*Msg),这个Msg和Tx参数是怎么来的？

```go
// This function should be used to register all interfaces that will be
// encoded/decoded by go-amino.
// Usage:
// `amino.RegisterInterface((*MyInterface1)(nil), nil)`
func (cdc *Codec) RegisterInterface(ptr interface{}, iopts *InterfaceOptions) {
	cdc.assertNotSealed()

	// Get reflect.Type from ptr.
	rt := getTypeFromPointer(ptr)
	if rt.Kind() != reflect.Interface {
		panic(fmt.Sprintf("RegisterInterface expects an interface, got %v", rt))
	}

	// Construct InterfaceInfo
	var info = cdc.newTypeInfoFromInterfaceType(rt, iopts)

	// Finally, check conflicts and register.
	func() {
		cdc.mtx.Lock()
		defer cdc.mtx.Unlock()

		cdc.collectImplementers_nolock(info)
		err := cdc.checkConflictsInPrio_nolock(info)
		if err != nil {
			panic(err)
		}
		cdc.setTypeInfo_nolock(info)
	}()
	/*
		NOTE: The above func block is a defensive pattern.

		First of all, the defer call is necessary to recover from panics,
		otherwise the Codec would become unusable after a single panic.

		This “defer-panic-unlock” pattern requires a func block to denote the
		boundary outside of which the defer call is guaranteed to have been
		called.  In other words, using any other form of curly braces (e.g.  in
		the form of a conditional or looping block) won't actually unlock when
		it might appear to visually.  Consider:

```
~~~go
	var info = ...
	{
		cdc.mtx.Lock()
		defer cdc.mtx.Unlock()

		...
	}
	// Here, cdc.mtx.Unlock() hasn't been called yet.
	```

	So, while the above code could be simplified, it's there for defense.
*/
~~~
}
----------------

## 20190805

