# 代码问题
### 1.go语言特有的桶(bucket)数据库,需要再学习

#### 初始化桶数据库的创建

路径: /home/gaojie/gopath/src/github.com/btcsuite/btcwallet/waddrmgr/manager.go

```go
    // Perform the initial bucket creation and database namespace setup.
   if err := createManagerNS(ns, ScopeAddrMap); err != nil {
     return maybeConvertDbError(err)
}
```

```go
// Generate the private passphrase salt.  This is used when hashing
	// passwords to detect whether an unlock can be avoided when the manager
	// is already unlocked.
	var privPassphraseSalt [saltSize]byte
	_, err = rand.Read(privPassphraseSalt[:])
	if err != nil {
		str := "failed to read random source for passphrase salt"
		return managerError(ErrCrypto, str, err)
	}
```
salt值

SALT值属于随机值。用户注册时，系统用来和用户密码进行组合而生成的随机数值，称作salt值，通称为加盐值。

背景：系统通常把用户的密码如MD5加密后，以密文形式保存在数据库中，来防止黑客偷窥。

产生：随着对MD5密文查询工具的出现，而很多用户的密码又设置简单，单纯的对用户密码进行MD5加密后保存，用密文很容易就能反查询得到某用户的密码。

原理：为用户密码添加Salt值，使得加密的得到的密文更加冷僻，不宜查询。即使黑客有密文查询到的值，也是加了salt值的密码，而非用户设置的密码。

salt值是随机生成的一组字符串，可以包括随机的大小写字母、数字、字符，位数可以根据要求而不一样。

用途：当用户首次提供密码时（通常是注册时），由系统自动添加随机生成的salt值，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的加盐值，

然后散列，再比较散列值，已确定密码是否正确。

其它：经过添加salt值处理的密码，即使用户设置的原密码是相同的，数据库中的密文却是不同的。


路径: /home/gaojie/gopath/src/github.com/btcsuite/btcwallet/waddrmgr/db.go

```go
// createManagerNS creates the initial namespace structure needed for all of
// the manager data.  This includes things such as all of the buckets as well
// as the version and creation date. In addition to creating the key space for
// the root address manager, we'll also create internal scopes for all the
// default manager scope types.
func createManagerNS(ns walletdb.ReadWriteBucket,
	defaultScopes map[KeyScope]ScopeAddrSchema) error {

	// First, we'll create all the relevant buckets that stem off of the
	// main bucket.(stem off:来自)
	mainBucket, err := ns.CreateBucket(mainBucketName)
	if err != nil {
		str := "failed to create main bucket"
		return managerError(ErrDatabase, str, err)
	}
	_, err = ns.CreateBucket(syncBucketName)
	if err != nil {
		str := "failed to create sync bucket"
		return managerError(ErrDatabase, str, err)
	}

	// We'll also create the two top-level scope related buckets as
	// preparation for the operations below.
	scopeBucket, err := ns.CreateBucket(scopeBucketName)
	if err != nil {
		str := "failed to create scope bucket"
		return managerError(ErrDatabase, str, err)
	}
	scopeSchemas, err := ns.CreateBucket(scopeSchemaBucketName)
	if err != nil {
		str := "failed to create scope schema bucket"
		return managerError(ErrDatabase, str, err)
	}

	// Next, we'll create the namespace for each of the relevant default
	// manager scopes.
	for scope, scopeSchema := range defaultScopes {
		// Before we create the entire namespace of this scope, we'll
		// update the schema mapping to note what types of addresses it
		// prefers.
		scopeKey := scopeToBytes(&scope)
		schemaBytes := scopeSchemaToBytes(&scopeSchema)
		err := scopeSchemas.Put(scopeKey[:], schemaBytes)
		if err != nil {
			return err
		}

		err = createScopedManagerNS(scopeBucket, &scope)
		if err != nil {
			return err
		}

		err = putLastAccount(ns, &scope, DefaultAccountNum)
		if err != nil {
			return err
		}
	}

	if err := putManagerVersion(ns, latestMgrVersion); err != nil {
		return err
	}

	createDate := uint64(time.Now().Unix())
	var dateBytes [8]byte
	binary.LittleEndian.PutUint64(dateBytes[:], createDate)
	err = mainBucket.Put(mgrCreateDateName, dateBytes[:])
	if err != nil {
		str := "failed to store database creation time"
		return managerError(ErrDatabase, str, err)
	}

	return nil
}

```

