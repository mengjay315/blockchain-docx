vnote_backup_file_826537664 /home/gaojie/Documents/vnote_notebooks/study/区块链学习/区块链跨链技术/Cosmos/Tendermint consensus 学习/Tendermint Documentation/Tendermint-1.md
# Tendermint

Tendermint Core is a blockchain application platform; it provides the equivalent of a web-server, database, and supporting libraries for blockchain applications written in any programming language. Like a web-server serving web applications, Tendermint serves blockchain applications.

Tendermint Core是一个区块链应用平台。它为使用任何编程语言编写的区块链应用程序提供了相当于Web服务器，数据库和支持库的功能。就像一个web服务器服务于web应用，Tendermint服务服务于区块链应用。

# What is Tendermint?

Tendermint是用于在许多机器上安全且一致地复制应用程序的软件。通过安全，我们的意思是即使超过三分之一的机器以任意一种方式失败，Tendermint也能工作。通过一致性，我们意味着，每一个没错误的机器都可以看到相似的交易，并且计算出相似的状态。在`分布式系统`中，`安全和一致性复制`是一个基本的问题;它在各种应用的容错性方面发挥着关键作用，从货币，选举到基础设施协调等。

能够容忍机器以任意方式失败，包括成为恶意的节点，就像拜占庭容错(BFT)。BFT的理论已经有十多年的历史了，由于像比特币和以太坊大量成功的区块链技术的出现，软件的实现仅仅在这几年变得流行。区块链技术只是在更现代化的环境中对BFT进行改造，重点在于点对点的网络和加密认证。该名称源自交易以区块的形式进行批处理，其中每个区块包含前一个区块的加密哈希，形成了一个链。特别地，区块链的数据结构确实优化了BFT的设计。

Tendermint包含了两个主要的技术组成：一个区块链共识引擎和一个通用的应用接口。共识引擎叫作Tendermint Core,它确保了相同的交易以相同的排序记录在每一个机器上。应用接口叫作应用区块链接口-Application BlockChain Interface (ABCI)，确保交易在任何编程语言中都可以被处理。与其他区块链和共识解决方案不同，它们是预先打包内置状态机（如花俏的键值存储或奇怪的脚本语言），开发人员可以使用Tendermint进行应用程序的BFT状态机复制，以任何编程语言编写的应用程序和开发环境都适合他们。

Tendermint旨在易于使用，易于理解，高性能，并且适用于各种分布式应用程序。

## Tendermint vs. X
--------------------------------------------------------------------------------------------------------------------------

Tendermint大致类似于两类软件。第一类是包含了分布式 kv存储，像Zookeeper，etcd和consul,它们都使用非BFT共识。第二类就是众所周知的“区块链技术”，包含了像比特币和以太坊这样的加密资产，还有像Hyperledger's Burrow一样可供选择的分布式账本设计。

### Zookeeper, etcd, consul

Zookeeper, etcd, and consul都在传统之上实现了kv存储，非BFT共识算法。Zookeeper使用了一个叫作`Zookeeper Atomic Broadcast`的`paxos`版本，而etcd使用了`Raft`共识算法，它是更加年轻化和简单的。一个典型的集群包含看3-5个机器，并且可以容忍多达1/2台机器的崩溃故障，但即使是单个拜占庭式故障也可能破坏系统。

每个产品都提供了一个特色键值存储的略微不同的实现，但所有产品通常都集中在为分布式系统提供基本服务，像动态配置，服务发现，锁定，领导者选举等等。

Tendermint本质上是和软件相似的，但是有两个关键的区别：
- 它是拜占庭容错(BFT)意味着，它可以容忍超过1/3的故障，而且这些故障可以包含任意的行为-包括黑客和恶意地攻击。它并不指定一个特定的应用，像复杂的kv存储。反而关注任意的状态机复制，因此开发者可以构建适合它们自己的应用逻辑，从键值存储到加密货币再到电子投票平台及其他。

### Bitcoin, Ethereum, etc.

Tendermint在比特币，以太坊等加密货币的传统中应运而生。目标是提供一个比比特币的POW更高效和安全的共识算法。在早期的时候，Tendermint构建了一个简单的资产，加入了共识，用户必须将单位货币“绑定”到一个安全的保证金中，如果他们行为不端可能会被撤销 - 这就是让Tendermint成为`POS`算法的原因。

从那时起，Tendermint已发展成为可以托管任意应用程序状态的通用区块链共识引擎。这意味着它可以用作其他区块链软件的共识引擎的`即插即用`替代品。因此，可以使用当前的以太坊代码库，无论是在Rust，Go还是Haskell中，并使用`Tendermint共识`将其作为ABCI应用程序运行。确实，[我们在以太坊上这么做了](https://github.com/cosmos/ethermint)。并且我们打算在比特币，ZCash和其他各种确定的应用程序上也这么做。

另一个在Tendermint上构建的加密资产的例子是[Cosmos network](http://cosmos.network/)。

### Other Blockchain Projects

Fabric采用与Tendermint类似的方法，但更关注`状态是如何管理`的，并且要求所有应用程序行为都在可能的许多docker容器中运行，它称之为“chaincode”的模块。它使用了一个[PBFT](http://pmg.csail.mit.edu/papers/osdi99.pdf)实现。来自IBM的团队，该团队被扩充以处理潜在的非确定性chaincode可以在Tendermint中将此基于docker的行为实现为ABCI应用程序，虽然延伸Tendermint处理非决定论仍然是未来的工作。

[Burrow](https://github.com/hyperledger/burrow)是以太坊虚拟机和以太坊交易机制的实现，具有名称注册，权限和原生合约的附加功能，以及替代区块链API。它使用Tendermint作为它的共识引擎，并且允许一个特别的应用状态。

## ABCI Overview
--------------------------------------------------------------------------------------------------------------------------

The [Application BlockChain Interface (ABCI)](https://github.com/tendermint/tendermint/tree/develop/abci) allows for Byzantine Fault Tolerant replication of applications written in any programming language.

`应用区块链接口`允许BFT复制用任何语言写的应用程序。

### Motivation

到现在为止，所有的区块链“stacks"(像比特币)有一个整体的设计。那就是每个区块链的堆栈都是一个单一的程序来处理所有涉及的分布式账本；这包括P2P连接，内存池广播交易，最近的区块的共识，账户余额，图灵完备的合约，用户级别的权限，等等。

使用一个整体的架构在计算机科学上是一个典型的不好的实践。这使得复用代码组件变得困难，并且尝试这样做会导致代码库的分支的复杂维护过程。当代码库在设计上不是模块化并且遭受“`spaghett`i代码”时，尤其如此。

另一个问题是整体的设计限制了区块链堆栈的语言（反之亦然）。在以太坊支持图灵完整字节码虚拟机的情况下，它限制了编译为字节码的语言；今天是这些语言是Serpent和Solidity。

相比之下，我们的方法是将共识引擎和P2P层与特定区块链应用程序的应用程序状态的细节分离。我们通过将应用程序的细节抽象到接口来实现这一点，该接口实现为套接字协议。

因此我们有一个接口，应用区块链接口(ABCI)，及其主要实现，即Tendermint套接字协议（TSP或Teaspoon）

### Intro to ABCI

Tendermint Core(共识引擎)通过满足ABCI的socker protocol与应用程序交流。

为了做一个类比，让我们讨论一个众所周知的加密资产比特币。比特币是每个节点都包含一个完整的受审查的未花费交易输出(UTXO)的加密资产区块链。如果一个人想要在ABCI之上创建一个类似比特币的系统，Tendermint Core将会有责任的：

- 在节点之间共享区块和交易。
- 创建一个规范化的、不可变的交易排序(区块链)。

区块链将会负责：
- 维护UTXO数据库
- 验证交易的加密签名
- 防止交易花费不存在的交易
- 允许客户端查询UTXO数据库

Tendermint能够通过在应用程序流程和共识流程之间提供非常简单的API（即ABCI）来分解区块链设计。

ABCI由3个主要消息类型组成，这些消息类型从核心传递到应用程序。应用程序回复相应的响应消息。

信息在[ABCI Message Types](https://github.com/tendermint/tendermint/blob/develop/abci/README.md#message-types)这里被指定。

**DeliverTx**消息是应用程序的工作原理。区块链中的每个交易都随此消息一起传递。应用程序需要根据当前状态，应用程序协议和交易的加密证书验证使用`DeliverTx`消息接收的每个交易。然后，经过验证的交易需要更新应用程序状态 - 例如，将值绑定到一个键值存储，或者更新UTXO数据库。

**CheckTx**信息是和`DeliverTx`相似的，但是它仅仅验证交易。Tendermint Core的内存池首先通过`CheckTx`检查交易的有效性，然后回复有效的交易给它的peers。例如，一个应用程序通过`CheckTx`检查在交易中增加的序列号，如果序列号是旧的将会返回一个错误。或者，他们可能会使用基于功能的系统，该系统需要在每次交易时更新功能。

**Commit**信息用于计算当前应用程序状态的加密凭证，然后把它放在下一个区块的头部。更新该状态的不一致现在将显示为区块链分叉，其捕获了一整类编程错误。这也简化了安全轻量级客户端的开发，因为Merkle-hash证明可以通过检查区块哈希来验证，并且区块哈希由仲裁签名。

可以有多个ABCI套接字连接到应用程序。`Tendermint Core创建了3个ABCI连接到应用程序`；一个用于在mempool中广播时验证交易，一个是共识引擎去运行区块提案，另一个是查询应用状态。

很明显，应用程序设计人员需要非常仔细地设计他们的消息处理程序，以创建一个有用的区块链，但这个架构提供了一个起点。下图说明了通过ABCI的消息流。

![](_v_images/20190623095213070_711394683.png)


## A Note on Determinism
------------------------------------------------------------------------------------------------------------------------------------------------------------

区块链处理交易的逻辑必须是确定性的。如果应用程序的逻辑不是确定性的，在Tendermint Core复制节点之间将不能达成共识。

Ethereum的Solidity是区块链应用的首选语言，除其他原因外，它是一个完全确定性的编程语言。然而，也可能使用已经存在的像java,c++,或者Go这样的流行语言创建确定性的区块链应用程序。游戏程序员和区块链开发人员已经熟悉通过避免非确定性来源创建确定性程序，例如：
- 随机数生成器(不需要确定性的播种)
- 多线程竞争条件(或者完全避免多线程)
- 系统计时器
- 未初始化的内存(在不安全的语言像C,C++)
- 浮点运算
- 语言特点是随机的(例如，在Go语言中的map迭代)

虽然程序员可以通过小心避免非确定性，但也可以为每种语言创建一个特殊的linter或静态分析器来检查确定性。未来我们可能会与合作伙伴合作创建此类工具。

## Consensus Overview
-------------------------------------------------------------------------------------------------------------------------------------------------

Tendermint是一种易于理解，大多是异步的BFT共识协议。该协议遵循一个简单的状态机，如下所示：

![](_v_images/20190623102125230_1460905445.png)


协议的参与者叫作**validators**；他们轮流地提出交易区块，并且给区块投票。区块提交到链上，每个高度都有一个区块。一个区块可能会提交失败，在那种情况下协议将会转到下一个循环里，并且一个新的`validator`为该高度提出一个区块。成功提交一个区块需要两个阶段的投票;我们称之为**pre-vote**和**pre-commit**。当超过2/3的`validator`在同一轮中为同一区块`pre-commit`时，将提交一个区块。

有一对夫妇在做波尔卡的照片，因为验证员正在做类似波尔卡舞的事情。当同一个区块超过2//3的验证者的`pre-vote`时，我们称之为`波尔卡`。在同一轮中每一个`pre-commit`都要被一个polka验证。

验证者可能由于多种原因而无法提交区块;当前的`提议人`可能是离线的，或者网络可能是慢的。Tendermint允许他们确定应该跳过一个validator。在投票进入下一轮之前，验证者会等待一小段时间从提议者那里收到完整的提案区块。这种对超时的依赖使得Tendermint成为一种弱同步协议，而不是异步协议。但是，协议的其余部分是异步的，并且验证器仅在听到超过三分之二的验证器集后才能取得进展。Tendermint的一个简化元素是它使用相同的机制来提交区块，就像它跳到下一轮一样。

假定少于1/3的验证者是拜占庭，Tendermint保证永远不会违反安全性 - 也就是说，验证者永远不会在同一高度提交冲突的区块。为此，它引入了一些`锁定规则`，这些规则可以调整流程图中可以遵循的路径。一旦验证器预先提交了一个区块，它就被锁定在该块上。然后，
- 它必须为锁定的区块预投票
- 如果在下一轮中有区块的`波尔卡`，它只能解锁并预提交一个新的区块。

## Stake
-----------------------------------------------------------------------------------------------------------------------------------------------

在许多系统中，并非所有验证器在共识协议中都具有相同的“权重”。因此，我们对三分之一或三分之二的验证器并不那么感兴趣，但是在总投票权的那些比例中，这些比例可能不是均匀地分布在各个验证者之间。

由于Tendermint可以复制任意应用程序，因此可以定义货币，并以该货币计算投票权。当投票权以原生货币计价时，该系统通常被称为`股权证明-POS`。
根据应用程序中的逻辑，验证者可以被强制绑定他们的货币到一个安全的保证金中，如果在共识协议中发现他们行为不端，这些保证金可能被毁掉。这为协议的安全性增加了经济因素，允许人们量化违反假设的成本，即不到三分之一的投票权是拜占庭。

Cosmos Network旨在将这种Proof-of-Stake机制用于作为ABCI应用程序实现的一系列加密货币。

The following diagram is Tendermint in a (technical) nutshell. [See here for high resolution version](https://github.com/mobfoundry/hackatom/blob/master/tminfo.pdf).

下图是（技术）简介中的Tendermint。请参阅此处获取高分辨率版本。







