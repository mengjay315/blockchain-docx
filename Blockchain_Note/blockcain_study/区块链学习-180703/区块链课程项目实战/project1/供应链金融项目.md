# 供应链金融项目

## 加密数字资产核心业务模型

![](_v_images/20190601115231198_1314599700.png)

这个交易所是一个资产确权交易中心，

![](_v_images/20190601123751030_797137568.png)

![](_v_images/20190601124303878_1912211150.png)

**保理公司对数字资产负责任**

![](_v_images/20190601124946125_698000325.png)

0518-03 35-

![](_v_images/20190601170328147_5234918.png)

![](_v_images/20190602164034588_617782205.png)

**对于90后和00后而言，打游戏买装备，这些都是从小就玩的，场景存在**

![](_v_images/20190602164258284_1453567955.png)

![](_v_images/20190601174913119_1602402024.png)


![](_v_images/20190601181042382_1099361035.png)

**require,业务层级的判断，开销很小，基本上不花费gas,**

**assert，代码层级的判断，开销大，花费的gas多，**


![](_v_images/20190601221430101_1508940519.png)

![](_v_images/20190601231332383_1704000206.png)


![](_v_images/20190601223309421_1762433726.png)

approveFreeze, 这个函数是自己加的，根据交易的业务逻辑加的，原来的ERC20接口中没有该方法

比如，买房要先付定金，这部分定金就被冻结了，



合约继承了ERC20接口中的方法，也可以自己增加方法。

![](_v_images/20190601232531706_747586336.png)

**区块链的核心是交易，写任何代码都要以交易为中心**

**最终落脚点，是交易类型，根据类型写代码**

ERC721

![](_v_images/20190602155721779_165652008.png)

![](_v_images/20190602160454780_1543706127.png)

![](_v_images/20190603123952372_1743402726.png)

![](_v_images/20190603124146311_1415336249.png)

![](_v_images/20190604094819541_934736775.png)

![](_v_images/20190604113926216_419765806.png)

业务流程图：

![](_v_images/20190604140645163_1209589594.png)

![](_v_images/20190604142336275_1311140861.png)

![](_v_images/20190604142526675_51359109.png)

![](_v_images/20190604144417192_1229912136.png)

![](_v_images/20190605110400297_1001267465.png)

truffle test错误
![](_v_images/20190605124027281_830707940.png)

![](_v_images/20190605160741344_1577255212.png)

平台合约：资产上架

![](_v_images/20190605161317834_1078783427.png)


![](_v_images/20190605163138212_646350203.png)

![](_v_images/20190605163054179_1056583068.png)

交易：平台卖721资产

![](_v_images/20190605164027471_1899730822.png)

![](_v_images/20190605172340995_87002909.png)

![](_v_images/20190605173019491_746773469.png)

![](_v_images/20190605174249014_1829555337.png)

#### 冻结买家钱的交易逻辑


冻结的这部分钱在平台这里，也可以做其他事情


#### 智能合约测试

智能合约写好后，要进行测试，测试是检验合约的很好方法


##### 看合约的方法：
看别人家写的合约时，先把单个合约中方法看一遍，再结合起来看一遍，还不是很清楚的话，结合着测试case看，


问题：这个在新的web3.js中已不存在

https://ethereumbuilders.gitbooks.io/guide/content/en/ethereum_javascript_api.html?tdsourcetag=s_pcqq_aiomsg
A note on big numbers in JavaScript

![](_v_images/20190606102618148_1877215745.png)

**BIgNumber Library**

https://github.com/MikeMcl/bignumber.js/

![](_v_images/20190606102759905_661372244.png)

![](_v_images/20190606102845901_1904185669.png)


![](_v_images/20190606094505643_2002881149.png)
##### .mul(200),  mul是什么？

![](_v_images/20190606094900317_1561400916.png)

![](_v_images/20190606094937926_312003668.png)


**Decimal**

https://www.npmjs.com/package/decimal

![](_v_images/20190606110211052_919634852.png)

## 没错误后，开始测试各个case

- 1 测试发行ERC721资产
- 1.1 测试发行单个ERC721资产

![](_v_images/20190606120626339_1244109816.png)


- 1.2 测试发行多个ERC721资产

![](_v_images/20190606170131761_192920756.png)

- 2 ERC721资产授权

- 2.1授权单个ERC721资产

![](_v_images/20190606174129275_1591942921.png)

truffle test 报错

![](_v_images/20190606174710314_1137416387.png)

错误的原因：如果是在真实的环境中，合约的调用者就谁授权的，不用加from, 现在是测试环境，要指定是谁授权的

![](_v_images/20190606175218395_490278910.png)

![](_v_images/20190606175455061_791778519.png)

- 2.1 授权多个ERC721资产(批量授权)

![](_v_images/20190606180554961_662700437.png)

![](_v_images/20190606180454851_2073966405.png)

- 3资产上架，平台合约   DMAPlatform.test.js
- 3.1 单个资产上架

![](_v_images/20190606214941950_2043102503.png)

我写的，出现了错误：

![](_v_images/20190606223643610_1806863850.png)

![](_v_images/20190606223712924_170239676.png)

问题说明：问题出现在beforeEach方法里：
- const tonkenAmount = Decimal(decimalsMul).mul(200)
- await token.transfer(buyer, tonkenAmount);

![](_v_images/20190606230709532_1359880075.png)

- transfer的第二个参数是uint256, 报的错就是说，传入transfer的第二个参数是无效的，和原来的uint256类型完全不相等
- console.log(tonkenAmount); 输出tonkenAmount的值，看看是什么，发现不是uint256类型

![](_v_images/20190606231038192_1158287559.png)

- await token.transfer(buyer, tonkenAmount.internal);  
- 我先是这样改，发现没有错误，
- 然后我又这样改，测试也没问题：

![](_v_images/20190606231322960_572628710.png)

- 原来的写法是下面这样的，decimalMul.mul(200) 的结果就是表示一个数值
- 我开始也这样写，test出错，web3.BigNumber 不是一个函数，所以查资料后，改成了上面的那种，
- 这个改好后，再test,发现错误 decimalsMul.mul 不是一个函数， 再查资料，可以看上面的，就改成了const tonkenAmount = Decimal(decimalsMul).mul(200).internal，
- 测试可以通过

![](_v_images/20190606231434915_1925587720.png)

 - Decimal(decimalsMul).mul(200).toNumber() 
 - 我把internal去掉，改成了 `.toNumber()`,   console.log(tokenAmount)也能得到结果，但是还是出错在transfer函数里的第二个参数那里

![](_v_images/20190606232513430_1979468417.png)

![](_v_images/20190606232820259_1970161637.png)


![](_v_images/20190606233308262_1079877184.png)
![](_v_images/20190606233342371_367476195.png)

是number类型，不是uint256类型

![](_v_images/20190606233557153_1272050597.png)

![](_v_images/20190606233626005_370432069.png)

这样也可以

![](_v_images/20190606233929527_1449527039.png)

##### js库， decimal 和 decimal.js的区别？

![](_v_images/20190607101110171_198095510.png)

![](_v_images/20190607101044846_253235789.png)


- 4.交易

![](_v_images/20190607103732086_392542592.png)


![](_v_images/20190607103402247_1734036757.png)

![](_v_images/20190607105110672_1215540515.png)


![](_v_images/20190607104430462_1572730922.png)

交易，单个资产，测试成功

![](_v_images/20190607130804819_1245228945.png)

![](_v_images/20190607130857018_1380651290.png)


- 获得授权信息

![](_v_images/20190607193132698_561382997.png)

![](_v_images/20190607193106193_186572271.png)

- truffle test

![](_v_images/20190607193216483_1027802735.png)


### 问题：id2=20,我发行了，3个，授权了3个，上架了3个，真正上架的资产是3个，id分别是 20， 21， 22，调用 platform.getLatestTokenId(id2);获得721资产的最后一个tokenId,我原来以为应该是22， 可是结果是23，困扰了我很久。

```solidity
  it('combine multi approve', async () => {
    const amount = Decimal(decimalsMul).mul(5).toString();
    await nftoken.mintMulti(saler, id2, 3, 'url2', true, true);
    await nftoken.approveMulti(platform.address, id2, 3, {from: saler});
    await platform.saveMultiApprove(saler, id2, 3, amount, {from: saler});

    const tokenId = await platform.getLatestTokenId(id2);
    console.log(tokenId.toString());
    assert.equal(tokenId, id2 + 3);
  });
```



从最开始的批量发行分析：首个tokenId是id2=20,发行3个，

assertMap-发行资产的资产列表，是个mapping, 首id 和 最后id的对应关系，开始发行时，这个map里没有数据，所以stratId = 20,最终发行完后，得到的是 20,21,22， 三个tokenId

最后一步，assertMap.update(20, 20+3),更新assertMap,那么在这个map里首和尾的对应关系变为20 >23,这样做的目的是，下次再发行资产时，比如再发行3个，合并之后，发行的资产总共有6个，原来是，20,21,22， 这次发行的三个是23+0， 23+1， 23+2， 即23,24,25，
这样做的目的是为了合并资产，



![](_v_images/20190611230944532_391984034.png)

![](_v_images/20190611231344657_223423189.png)
![](_v_images/20190611230922842_1765195991.png)

类似的处理还有：批量授权，批量保存授权，分别对应授权的mapping,  上架资产的mapping, 这两个mapping都是首个tokenid和最后一个tokenid的对应关系，一个是保存approved的资产，另一个是保存上架的资产， 当下次再授权资产和上架资产时，从这个mapping里取出最后一个tokenId，接着进行approve，会根据取出的最后一个tokenId得到其他tokenId，