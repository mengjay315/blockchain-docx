# ERC-721标准

现在我们看到的各种加密猫都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于**将物理世界的资产映射到区块链上**。

ERC-721 Non-Fungible Token Standard:ERC-721 非同质的代币标准   |   fungible(代替的，可取代的）

## Simple Summary

A standard interface for non-fungible tokens, also known as deeds.

一个非同质化token标准接口，也被认为是契约。

## Abstract

The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs.

下面的标准允许在智能合约中实现NFTs的标准的API.这个标准提供了基本的功能去追踪和转让NFTs.

We considered use cases of NFTs being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers ("operators"). NFTs can represent ownership over digital or physical assets. We considered a diverse universe of assets, and we know you will dream up many more:

我们认为NFT的使用案例由个人拥有和交易，以及委托给第三方经纪人/钱包/拍卖商（“运营商”）。 **NFT可以代表对数字或实物资产的所有权**。 我们考虑了各种各样的资产，我们知道你会创造更多：

- Physical property — houses, unique artwork
    实物资产 --房子，唯一的艺术品
- Virtual collectables — unique pictures of kittens, collectable cards
     虚拟的收藏品 --唯一的猫的照片，可收藏的明信片
- "Negative value" assets — loans, burdens and other responsibilities
    “负值”资产 - 贷款，负担和其他责任
    

In general, all houses are distinct and no two kittens are alike. NFTs are *distinguishable* and you must track the ownership of each one separately.

通常，所有的房子是不同的，没有两只猫是相似的。**NFTs是可区别的，你必须分别地追踪每一个的所有权**。

## Motivation(动机）

A standard interface allows wallet/broker/auction applications to work with any NFT on Ethereum. We provide for simple ERC-721 smart contracts as well as contracts that track an *arbitrarily large* number of NFTs. Additional applications are discussed below.

一个标准接口允许钱包/经纪人/拍卖应用程序与以太坊上的任何NFT一起使用。 我们提供简单的ERC-721智能合约以及追踪*任意大*数量的NFT的合约。 其他应用将在下面讨论。

This standard is inspired by the ERC-20 token standard and builds on two years of experience since EIP-20 was created. EIP-20 is insufficient for tracking NFTs because each asset is distinct (non-fungible) whereas each of a quantity of tokens is identical (fungible).

这个标准是受到了ERC-20 token标准的启发，自从EIP-20创立以来，这个标准也建立了两年的经验。EIP-20不足以追踪NFT，因为每个资产都是不同的（不可互换的），而一定数量的token中的每一个都是相同的（可互换的）。

Differences between this standard and EIP-20 are examined below.

下面讨论该标准与EIP-20之间的差异。

## Specification(详述）

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

**Every ERC-721 compliant contract must implement the `ERC721` and `ERC165` interfaces** (subject to "caveats" below):

每一个ERC-721兼容合约必须实现`ERC721`和`ERC165`接口(受制于以下“警告”).

### Caveats(警告)

The 0.4.20 Solidity interface grammar is not expressive enough to document the ERC-721 standard. A contract which complies with ERC-721 MUST also abide by the following:

0.4.20 Solidity接口语法的表达力不足以记录ERC-721标准。一个遵从ERC-721标准的合约也必须遵守下面的：

- Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: `payable`, implicit nonpayable, `view`, and `pure`. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a `payable` function in this interface may be implemented as nonpayble (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.20 is that you can edit this interface to add stricter mutability before inheriting from your contract.
- Solidity issue #3419: A contract that implements `ERC721Metadata` or `ERC721Enumerable` SHALL also implement `ERC721`. ERC-721 implements the requirements of interface ERC-165.
- Solidity issue #2330: If a function is shown in this specification as `external` then a contract will be compliant if it uses `public` visibility. As a workaround for version 0.4.20, you can edit this interface to switch to `public` before inheriting from your contract.
- Solidity issues #3494, #3544: Use of `this.*.selector` is marked as a warning by Solidity, a future version of Solidity will not mark this as an error.

- Solidity 问题 #3412:上述接口包括每个函数的显式(explict)可变性(mutability)保证(guarantees).可变性保证依次由弱到强：`payable`,隐含的(implict) nopayable,`view`,和 `pure`. 你的实现必须满足在这个接口上的可见性保证，并且可能要满足更强的保证。例如，在你的合约里，一个在这个接口中的 `payable`函数可能要被作为nopayable实现(没有指定的可见性状态).我们期待一个新的Solidity版本将会允许你的更严格的合约继承这个接口，但是对于0.4.20有一个替代方法，即在你的合约继承它之前，你可以编辑这个接口添加更加严格的可变性，
- Solidity 问题 #3419:一个实现 `ERC721Metada` 或者 `ERC721Enumerable` 的合约也应该实现 `ERC721`.ERC-721的实现又要求实现ERC-165接口。
- Solidity 问题 #2330: 如果一个函数表现出 `external`这样的说明，一个合约将会被应允的,如果它用 `public`可见性。在从你的合约继承之前，作为0.4.20版本的替代方法，你可以编辑这个接口转为 `public`,
- Solidity 问题 #3494:使用`this.*.selector` 被Solidity标记为警告，Solidity将来的版本将会标记这个作为一个错误。

*If a newer version of Solidity allows the caveats to be expressed in code, then this EIP MAY be updated and the caveats removed, such will be equivalent to the original specification.*

如果新的Solidity版本允许这些警告在代码中表达，然后这个EIP将会更新，并且警告也会被移除，这样，将会和原来的规范相等的。

## Rationale(合理的）

There are many proposed uses of Ethereum smart contracts that depend on tracking distinguishable assets. Examples of existing or planned NFTs are LAND in Decentraland, the eponymous punks in CryptoPunks, and in-game items using systems like DMarket or EnjinCoin. Future uses include tracking real-world assets, like real-estate (as envisioned by companies like Ubitquity or Propy). It is critical in each of these cases that these items are not "lumped together" as numbers in a ledger, but instead each asset must have its ownership individually and atomically tracked. Regardless of the nature of these assets, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional asset management and sales platforms.

以太坊智能合约的许多建议用途依赖于跟踪可区分的资产.现有的或计划的NFT的示例是Decentraland中的LAND。CryptoPunks中的同名朋友，以及使用DMarket或EnjinCoin等系统的游戏内物品。将来使用包括真实世界的资产，像实际的房地产(正如Ubitquity或Propy等公司所设想的那样).在每种情况下，这些项目不是作为分类账中的数字“集中在一起”，而是每个资产必须单独和原子地跟踪其所有权，这一点至关重要。 无论这些资产的性质如何，如果我们拥有允许跨功能资产管理和销售平台的标准化接口，生态系统将更加强大。

**"NFT" Word Choice**

"NFT" was satisfactory to nearly everyone surveyed and is widely applicable to a broad universe of distinguishable digital assets. We recognize that "deed" is very descriptive for certain applications of this standard (notably, physical property).

几乎所有受访者都对“NFT”表示满意，并广泛适用于广泛的可区分的数字资产领域。我们认识到“契约”对于这个标准的某些应用（特别是物理资产）非常具有描述性。

*Alternatives considered: distinguishable asset, title, token, asset, equity, ticket*

*考虑的替代方案：可区分资产，所有权，代币，资产，股东权益，票据*

**NFT Identifiers**(标识符）

Every NFT is identified by a unique `uint256` ID inside the ERC-721 smart contract. This identifying number SHALL NOT change for the life of the contract. The pair `(contract address, uint256 tokenId)` will then be a globally unique and fully-qualified identifier for a specific asset on an Ethereum chain. While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a "black box". Also note that a NFTs MAY become invalid (be destroyed). Please see the enumerations functions for a supported enumeration interface.

在ERC-721智能合约里面，每一个NFT被标示为一个唯一的 `uint256`ID。这个标示数字不会改变合约的寿命。一对`(contract address, unit256 tokenId)`然后，它将成为以太坊链上特定资产的全球唯一且完全合格的标识符.虽然一些ERC-721智能合约可能会发现从ID 0开始很方便，并且每个新NFT只需增加一个,调用者不要假设ID号具有任何特定模式，并且必须将ID视为“黑匣子”。 另请注意，NFT可能无效（被销毁）。 请参阅支持的枚举接口的枚举函数。

The choice of `uint256` allows a wide variety of applications because UUIDs and sha3 hashes are directly convertible to `uint256`.

`uint256`的选择允许各种各样的应用程序，因为UUID和sha3哈希可以直接转换为`uint256`。

**Transfer Mechanism**(交易机制）

ERC-721 standardizes a safe transfer function `safeTransferFrom` (overloaded with and without a `bytes` parameter) and an unsafe function `transferFrom`. Transfers may be initiated by:

ERC-721使一个安全的转移函数`safeTransferFrom`(带有和没有`bytes`参数的重载)和不安全的函数`transferFrom`标准化.转账可以被以下发起：

- The owner of an NFT      (NFT的所有者)
- The approved address of an NFT     (一个NFT批准的地址)
- An authorized operator of the current owner of an NFT     (一个NFT所有者授权的操作）

Additionally, an authorized operator may set the approved address for an NFT. This provides a powerful set of tools for wallet, broker and auction applications to quickly use a *large* number of NFTs.

此外，一个经授权的操作可以设置一个NFT批准的地址.这为钱包，经纪人和拍卖应用程序提供了一套强大的工具，可以快速使用*大量*的NFTs。

The transfer and accept functions' documentation only specify conditions when the transaction MUST throw. Your implementation MAY also throw in other situations. This allows implementations to achieve interesting results:

转移和接受函数的文档仅指定交易必须抛出的条件。 你的实现也可能会引发其他情况。 这允许实现获得有趣的结果：

- **Disallow transfers if the contract is paused** — prior art, CryptoKitties deployed contract, line 611
- **如果合约是被暂停的，不同意转移token** —先前的美术作品，加密猫部署的合约， 611行
- **Blacklist certain address from receiving NFTs** — prior art, CryptoKitties deployed contract, lines 565, 566
- **来自与接收NFTs的黑名单确定的地址** —先前的美术作品，加密猫部署的的合约，565行， 566行
- **Disallow unsafe transfers** — `transferFrom` throws unless `_to` equals `msg.sender` or `countOf(_to)` is non-zero or was non-zero previously (because such cases are safe)
-** 不同意不安全的转移**— `transferFrom`函数将会抛出错误，除非 `_to` 等于 `msg.sender` 或者`countOf(_to)`是非零的或者之前就是非零的(因为这种情况是安全的).
- **Charge a fee to both parties of a transaction** — require payment when calling `approve` with a non-zero `_approved` if it was previously the zero address, refund payment if calling `approve` with the zero address if it was previously a non-zero address, require payment when calling any transfer function, require transfer parameter `_to` to equal `msg.sender`, require transfer parameter `_to` to be the approved address for the NFT
- **向交易双方收取费用** —如果以前是零地址，则在使用非零“_approved”调用“approve”时需要付款;如果以前是非零地址，则在使用零地址调用“approve”时退款，在调用任何转移函数时需要付款，要求transfer参数`_to`等于`msg.sender`，要求transfer参数`_to`为NFT的批准地址

- **Read only NFT registry** — always throw from `unsafeTransfer`, `transferFrom`, `approve` and `setApprovalForAll`
- **只读的NFT注册信息** — 总是抛出错误从 `unsafeTranfer`, `trabsferFrom`, `approve`and `setApprovalForAll`

Failed transactions will throw, a best practice identified in ERC-223, ERC-677, ERC-827 and OpenZeppelin's implementation of SafeERC20.sol. ERC-20 defined an `allowance` feature, this caused a problem when called and then later modified to a different amount, as on OpenZeppelin issue \#438. In ERC-721, there is no allowance because every NFT is unique, the quantity is none or one. Therefore we receive the benefits of ERC-20's original design without problems that have been later discovered.

失败的交易将会抛出错误，ERC-223，ERC-677，ERC-827和OpenZeppelin实施的SafeERC20.sol中确定的最佳实践。 ERC-20定义了一个`allowance`功能，这在调用时引起了一个问题，然后被修改为不同的数量，就像OpenZeppelin问题 ＃438一样。 在ERC-721中，没有任何余量((allowance)，因为每个NFT都是唯一的，数量是无或一个。 因此，我们可以获得ERC-20原始设计的优点，而不会出现后来发现的问题。

Creating of NFTs ("minting") and destruction NFTs ("burning") is not included in the specification. Your contract may implement these by other means. Please see the `event` documentation for your responsibilities when creating or destroying NFTs.

创建NFTs(("minting"-铸造)和销毁NFTs("burning")是不包括在这个规范里的。你的合约可以通过其他方式实现。在创建或销毁NFT时，请参阅`event`文档以了解您的职责。

We questioned if the `operator` parameter on `onERC721Received` was necessary. In all cases we could imagine, if the operator was important then that operator could transfer the token to themself and then send it -- then they would be the `from` address. This seems contrived because we consider the operator to be a temporary owner of the token (and transferring to themself is redundant). When the operator sends the token, it is the operator acting on their own accord, NOT the operator acting on behalf of the token holder. This is why the operator and the previous token owner are both significant to the token recipient.

我们质疑`onERC721Received`上的`operator`参数是必要的。在所有我们能想象到的情况中，如果运算符(oprator)很重要，那么该运算符可以将token转移给自己然后发送它 - 那么它们就是`from`地址.这似乎是设计的，因为我们认为运算符(oprator)是token的临时所有者(转移给他们自己是多余的).当operator发送token时，这是operator自发的行动(翻译的不准确)，不是作用于代表token持有者的操作符(翻译的也不准确)。这就是为什么 operator和 先前的token所有者对于token接受者都是有意义的。

*Alternatives considered: only allow two-step ERC-20 style transaction, require that transfer functions never throw, require all functions to return a boolean indicating the success of the operation.*

可供选择的考虑：仅仅允许两步ERC-20方式的交易，要求所有的函数从来不抛出错误，所有的函数返回一个布尔值，表明操作成功了。

**ERC-165 Interface**(ERC-165接口)

We chose Standard Interface Detection (ERC-165) to expose the interfaces that a ERC-721 smart contract supports.

我们选择标准的接口探测(ERC-165)去暴露一个ERC-721智能合约支持的接口。

A future EIP may create a global registry of interfaces for contracts. We strongly support such an EIP and it would allow your ERC-721 implementation to implement `ERC721Enumerable`, `ERC721Metadata`, or other interfaces by delegating to a separate contract.

一个将来的EIP可能会创造一个全局的关于合约接口的注册信息.我们强烈得支持这样一个EIP，并且它将会允许你的ERC-721合约实现去实现`ERC721Enumerable`, `ERC721Metada`或者被委托在一个分开的合约里的接其它接口。

**Gas and Complexity** (regarding the enumeration extension)

**Gas和复杂性**(关于列举扩展)

This specification contemplates implementations that manage a few and *arbitrarily large* numbers of NFTs. If your application is able to grow then avoid using for/while loops in your code (see CryptoKitties bounty issue \#4). These indicate your contract may be unable to scale and gas costs will rise over time without bound.

该规范考虑管理少量和任意数量的NFTs的实现.如果你的应用能够扩展，然后在你的代码中避免使用for/while循环(可以看加密猫的发放奖金问题 #4).这表明你的合约可能无法扩大规模，gas费用将随着时间的推移毫无约束地上涨。

We have deployed a contract, XXXXERC721, to Testnet which instantiates and tracks 340282366920938463463374607431768211456 different deeds (2^128). That's enough to assign every IPV6 address to an Ethereum account owner, or to track ownership of nanobots a few micron in size and in aggregate totalling half the size of Earth. You can query it from the blockchain. And every function takes less gas than querying the ENS.

我们已经部署了一个合约，XXXXERC721,到Testnet，它实例化并跟踪340282366920938463463374607431768211456个不同的契约(2^128)，这足以将每个IPV6地址分配给一个Ethereum帐户所有者，或者跟踪纳米机器人的所有权，这些纳米机器人的尺寸只有几微米，总体上只有Earth的一半大小。你可以在blockchain上查询它，每一个函数都比查询ENS花费更少的gas。

This illustration makes clear: the ERC-721 standard scales.

这个例子说明得很清楚:ERC-721标准尺度。

*Alternatives considered: remove the asset enumeration function if it requires a for-loop, return a Solidity array type from enumeration functions.*

可供选择的考虑:如果需要一个for循环的话，移除资产枚举函数，从枚返回一个Solidity array类型.

**Privacy**(隐私)

Wallets/brokers/auctioneers identified in the motivation section have a strong need to identify which NFTs an owner owns.

在动机(motivation)部分识别出的钱包/经纪人/拍卖商有强烈的需求来确定所有者拥有哪些NFTs。

It may be interesting to consider a use case where NFTs are not enumerable, such as a private registry of property ownership, or a partially-private registry. However, privacy cannot be attained because an attacker can simply (!) call `ownerOf` for every possible `tokenId`.

考虑一个NFTs不可枚举的用例可能会很有趣,比如一个财产所有权的私有注册，或者一个部分私有的注册.然而，隐私是不能获得的，因为一个attacher可以简单地回调`ownerOf` 对于每一个可能的 `tokenId`.

**Metadata Choices** (metadata extension)    **元数据选择**(元数据扩展)

We have required `name` and `symbol` functions in the metadata extension. Every token EIP and draft we reviewed (ERC-20, ERC-223, ERC-677, ERC-777, ERC-827) included these functions.

我们要求`name` 和`symbol`函数在元数据扩展里.我们收到的每一个 token EIP和草案(ERC-20,ERC-223,ERC-677,ERC-777,ERC-827)包含这些函数.

We remind implementation authors that the empty string is a valid response to `name` and `symbol` if you protest to the usage of this mechanism. We also remind everyone that any smart contract can use the same name and symbol as *your* contract. How a client may determine which ERC-721 smart contracts are well-known (canonical) is outside the scope of this standard.

我们提醒实现作者，如果您反对使用这种机制，空字符串是对“name”和“symbol”函数的有效响应.我们还提醒大家，任何智能合约都可以使用与“你的”合约相同的名称和符号.客户如何确定哪些ERC-721智能契约是众所周知的(规范的)不在本标准的范围之内。

A mechanism is provided to associate NFTs with URIs. We expect that many implementations will take advantage of this to provide metadata for each NFT. The image size recommendation is taken from Instagram, they probably know much about image usability. The URI MAY be mutable (i.e. it changes from time to time). We considered an NFT representing ownership of a house, in this case metadata about the house (image, occupants, etc.) can naturally change.

一个机制提供了NFTs和URIs的关联。我们期待很多实现利用这个机制为每个NFT提供元数据.推荐的照片大小来自于照片分享平台,他们可能知道更多关于照片的可用性.URI可能是易变的(随着时间的改变而改变).我们认为一个NFT代表一个房子的所有权，在这种情况下，包括房子的元数据(照片，居住者，等等)可以自然而然的改变。

Metadata is returned as a string value. Currently this is only usable as calling from `web3`, not from other contracts. This is acceptable because we have not considered a use case where an on-blockchain application would query such information.

**Metadata被返回一个 string value**.当然了，**它仅仅可以从`web3`回调,不能从其他合约回调.这是可以接受的**，因为我们没有考虑到一个使用情况：没有区块链的应用将会查询这些信息。

*Alternatives considered: put all metadata for each asset on the blockchain (too expensive), use URL templates to query metadata parts (URL templates do not work with all URL schemes, especially P2P URLs), multiaddr network address (not mature enough)*

可供选择的考虑：**把每个资产的元数据都放到区块链上(太昂贵了)，使用URL模板去查询元数据部分**(URL模板并不适用于所有的URL模式，尤其是 P2P URLs),多网络地址(不够成熟的)。

**Community Consensus**(社群共识)

A significant amount of discussion occurred on the original ERC-721 issue, additionally we held a first live meeting on Gitter that had good representation and well advertised (on Reddit, in the Gitter #ERC channel, and the original ERC-721 issue). Thank you to the participants:

在最初的ERC-721问题上进行了大量的讨论，此外，我们还在Gitter上举行了第一次现场会议，该会议具有良好的代表性和良好的广告效果(在Reddit、Gitter #ERC频道和最初的ERC-721问题上)。感谢各位嘉宾:

- [@ImAllInNow](https://github.com/imallinnow) Rob from DEC Gaming / Presenting Michigan Ethereum Meetup Feb 7
- [@Arachnid](https://github.com/arachnid) Nick Johnson
- [@jadhavajay](https://github.com/jadhavajay) Ajay Jadhav from AyanWorks
- [@superphly](https://github.com/superphly) Cody Marx Bailey - XRAM Capital / Sharing at hackathon Jan 20 / UN Future of Finance Hackathon.
- [@fulldecent](https://github.com/fulldecent) William Entriken

A second event was held at ETHDenver 2018 to discuss distinguishable asset standards (notes to be published).

2018年在ETHDenver举办了第二场活动，讨论不同的资产标准(即将发布的注释)。

We have been very inclusive in this process and invite anyone with questions or contributions into our discussion. However, this standard is written only to support the identified use cases which are listed herein.

我们在这个过程中非常包容，并邀请任何有问题或有贡献的人加入我们的讨论。但是，本标准仅用于支持本文列出的已标识的用例。

## Backwards Compatibility(向后兼容)

We have adopted `balanceOf`, `totalSupply`, `name` and `symbol` semantics from the ERC-20 specification. An implementation may also include a function `decimals` that returns `uint8(0)` if its goal is to be more compatible with ERC-20 while supporting this standard. However, we find it contrived to require all ERC-721 implementations to support the `decimals` function.

我们采用了ERC-20规范中的“balanceOf”、“totalSupply”、“name”和“symbol”语义.一个实现还可以包括一个函数`decimals`，如果它的目标是在支持这个标准时与ERC-20更兼容，则返回`uint8（0）`.然而，我们发现它设法要求所有ERC-721实现都支持`decimals`函数。

Example NFT implementations as of February 2018: 

截至2018年2月的NFT实现示例:

- CryptoKitties -- Compatible with an earlier version of this standard.
- 加密猫 --兼容这个标准更早的版本
- CryptoPunks -- Partially ERC-20 compatible, but not easily generalizable because it includes auction functionality directly in the contract and uses function names that explicitly refer to the assets as "punks".
- 加密朋克 --部分兼容ERC-20，但不容易推广，因为它直接在合同中包含拍卖功能，并使用明确将资产称为“punks”的功能名称。

- Auctionhouse Asset Interface -- The author needed a generic interface for the Auctionhouse ÐApp (currently ice-boxed). His "Asset" contract is very simple, but is missing ERC-20 compatibility, `approve()` functionality, and metadata. This effort is referenced in the discussion for EIP-173.

- 拍卖房子资产接口--对于房屋拍卖的DApp (currently ice-boxed)，作者需要一个一般的接口。它的资产是非常简单的，但是缺失了与ERC-20的兼容，`approve()`功能和元数据。在EIP-173的讨论中引用了这一努力。

Note: "Limited edition, collectible tokens" like Curio Cards and Rare Pepe are *not* distinguishable assets. They're actually a collection of individual fungible tokens, each of which is tracked by its own smart contract with its own total supply (which may be `1` in extreme cases).

注意：”有限的版本，可收集的tokens“像Curio(古董)，卡片和稀少的水果是不可区分的资产。它们实际上是个体可替代的tokens的集合，每个都由自己的智能合约跟踪自己的总供应量（在极端情况下可能是“1”）。

The `onERC721Received` function specifically works around old deployed contracts which may inadvertently return 1 (`true`) in certain circumstances even if they don't implement a function (see Solidity DelegateCallReturnValue bug). By returning and checking for a magic value, we are able to distinguish actual affirmative responses versus these vacuous `true`s.

`onERC721Received`函数专门用于旧的部署的合约，即使它们没有实现函数，也可能在某些情况下无意中返回1（`true`）（参见Solidity DelegateCallReturnValue bug）。 通过返回并检查魔法值，我们能够区分实际的肯定响应与这些空洞的“true”。

## Test Cases(测试案例)

0xcert ERC-721 Token includes test cases written using Truffle.

0xcert ERC-721Token包含了用Truffle写的test cases.

## Implementations(实现)

0xcert ERC721 -- a reference implementation

Oxcert ERC-721 --一个接口实现

- MIT licensed, so you can freely use it for your projects
- MIT得到许可的，因此你可以轻松地在你的项目里使用
- Includes test cases
- 包含 test cases
- Active bug bounty, you will be paid if you find errors
- 积极的bug赏金，如果你发现错误，你将获得报酬
Su Squares -- an advertising platform where you can rent space and place images

Su Squares -- 一个广告平台在那里你可以租借空间和替换照片

- Complete the Su Squares Bug Bounty Program to seek problems with this standard or its implementation
- 完成Su Squares Bug Bounty计划以寻求此标准或其实施的问题
- Implements the complete standard and all optional interfaces
- 实现完整的标准和所有可选接口

ERC721ExampleDeed -- an example implementation

ERC721ExampleDeed  - 一个示例实现

- Implements using the OpenZeppelin project format
- 使用OpenZeppelin项目格式的实现

XXXXERC721, by William Entriken -- a scalable example implementation

XXXXERC721，by：William Entriken  - 一个可扩展的示例实现

- Deployed on testnet with 1 billion assets and supporting all lookups with the metadata extension. This demonstrates that scaling is NOT a problem.
- 部署在具有10亿资产的testnet上，并支持具有元数据扩展的所有查找。 这表明规模不是问题。

## References(参考)

**Standards**(标准)

1. ERC-20 Token Standard. https://eips.ethereum.org/EIPS/eip-20
1. ERC-165 Standard Interface Detection. https://eips.ethereum.org/EIPS/eip-165
1. ERC-173 Owned Standard. https://eips.ethereum.org/EIPS/eip-173
1. ERC-223 Token Standard. https://eips.ethereum.org/EIPS/eip-223
1. ERC-677 `transferAndCall` Token Standard. https://eips.ethereum.org/EIPS/eip-677
1. ERC-827 Token Standard. https://eips.ethereum.org/EIPS/eip-827
1. Ethereum Name Service (ENS). https://ens.domains
1. Instagram -- What's the Image Resolution? https://help.instagram.com/1631821640426723
1. JSON Schema. https://json-schema.org/
1. Multiaddr. https://github.com/multiformats/multiaddr
1. RFC 2119 Key words for use in RFCs to Indicate Requirement Levels. https://www.ietf.org/rfc/rfc2119.txt

**Issues**(问题)

1. The Original ERC-721 Issue. https://github.com/ethereum/eips/issues/721
1. Solidity Issue \#2330 -- Interface Functions are External. https://github.com/ethereum/solidity/issues/2330
1. Solidity Issue \#3412 -- Implement Interface: Allow Stricter Mutability. https://github.com/ethereum/solidity/issues/3412
1. Solidity Issue \#3419 -- Interfaces Can't Inherit. https://github.com/ethereum/solidity/issues/3419
1. Solidity Issue \#3494 -- Compiler Incorrectly Reasons About the `selector` Function. https://github.com/ethereum/solidity/issues/3494
1. Solidity Issue \#3544 -- Cannot Calculate Selector of Function Named `transfer`. https://github.com/ethereum/solidity/issues/3544
1. CryptoKitties Bounty Issue \#4 -- Listing all Kitties Owned by a User is `O(n^2)`. https://github.com/axiomzen/cryptokitties-bounty/issues/4
1. OpenZeppelin Issue \#438 -- Implementation of `approve` method violates ERC20 standard. https://github.com/OpenZeppelin/zeppelin-solidity/issues/438
1. Solidity DelegateCallReturnValue Bug. https://solidity.readthedocs.io/en/develop/bugs.html#DelegateCallReturnValue

**Discussions**(讨论)

1. Reddit (announcement of first live discussion). https://www.reddit.com/r/ethereum/comments/7r2ena/friday_119_live_discussion_on_erc_nonfungible/
1. Gitter #EIPs (announcement of first live discussion). https://gitter.im/ethereum/EIPs?at=5a5f823fb48e8c3566f0a5e7
1. ERC-721 (announcement of first live discussion). https://github.com/ethereum/eips/issues/721#issuecomment-358369377
1. ETHDenver 2018. https://ethdenver.com

**NFT Implementations and Other Projects****(NFT实现和其它项目)**

1. CryptoKitties. https://www.cryptokitties.co
1. 0xcert ERC-721 Token. https://github.com/0xcert/ethereum-erc721
1. Su Squares. https://tenthousandsu.com
1. Decentraland. https://decentraland.org
1. CryptoPunks. https://www.larvalabs.com/cryptopunks
1. DMarket. https://www.dmarket.io
1. Enjin Coin. https://enjincoin.io
1. Ubitquity. https://www.ubitquity.io
1. Propy. https://tokensale.propy.com
1. CryptoKitties Deployed Contract. https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code
1. ** Su Squares Bug Bounty Program. https://github.com/fulldecent/su-squares-bounty**
1. XXXXERC721. https://github.com/fulldecent/erc721-example
1. ERC721ExampleDeed. https://github.com/nastassiasachs/ERC721ExampleDeed
1. Curio Cards. https://mycuriocards.com
1. Rare Pepe. https://rarepepewallet.com
1. Auctionhouse Asset Interface. https://github.com/dob/auctionhouse/blob/master/contracts/Asset.sol
1. OpenZeppelin SafeERC20.sol Implementation. https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/SafeERC20.sol

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

